## **TCP 기반 채팅 프로그램을 Docker 컨테이너에서 실행해볼 것이다.**

1. 채팅 서버와 여러 클라이언트를 TCP로 연결
2. 각 컴포넌트를 Docker 컨테이너로 분리
3. 컨테이너 간 통신 통해 실시간 채팅 구현

<br>
<br>

## **단계별 과정**
### **1단계: 로컬에서 채팅 기능 구현**

- 서버: 여러 클라이언트 연결받고 메시지 브로드캐스트
- 클라이언트: 사용자 입력을 서버로 보내고, 받은 메시지 출력
- 스레드/비동기 처리로 동시 통신 구현

---

### **2단계: 채팅 서버 컨테이너화**

- `Dockerfile` 작성 (언어 런타임 포함)
- 서버 코드 복사 및 실행 설정
- 포트 노출 (`EXPOSE`, `p` 옵션으로 테스트)
- 단일 서버 컨테이너 실행 확인

---

### **3단계: 클라이언트 컨테이너화**

- 클라이언트 실행용 `Dockerfile` 만들기
- 여러 개의 클라이언트를 컨테이너로 실행
- 입력을 받을 수 있도록 `docker exec -it` 또는 터미널 분리

---

### **4단계: 네트워크 연결 구성**

- 사용자 정의 `bridge` 네트워크 생성
- 서버와 클라이언트를 동일 네트워크에 연결
- 컨테이너 이름을 호스트로 사용해 통신 (`server:포트번호`)
- 서버 → 클라이언트 메시지 흐름 테스트

---

### **5단계: Docker Compose 사용 (선택)**

- `docker-compose.yml` 파일로 서버 + 다수 클라이언트 실행
- 네트워크 자동 생성 및 서비스 간 연결 구성
- 클라이언트 수 늘리기 (scale or service 복제)

---

### **6단계: 테스트 및 디버깅**

- 서버 로그로 클라이언트 연결/메시지 확인
- 클라이언트 로그로 수신 메시지 확인
- `docker logs`, `docker exec`, `docker network inspect` 사용

---

### **7단계: 리팩토링 및 정리**

- 이미지 경량화 (불필요한 파일 제거, `.dockerignore`)
- 실행 스크립트 작성 (`start.sh`, `build.sh`)
- README에 구조, 실행법, 네트워크 설명 정리
